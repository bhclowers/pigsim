--[[
 Note: This code generates SLIM board based upon user input.
 The lua assumes that the velocity and pressure data are manuall set or imported from comsol. 
 If not, comment out those segments and provide the values appropriately.

 The parameter file that helps define the electrode geometries and initial settings is
 obtained from the paired python script that includes a limited graphical representation
 of the board to be examined

 Additionally, this lua file is looking for a gem file, also written to disk from the python script,
 that contains the user defined electrode configurations. 

 It should also be noted that depending upon the geometry of the SLIM parameter the user
 may also need to manually adjust x,y,z locations of the ions. At this stage, I simply don't know
 how to programatically do that via lua (though I suppose it could be done in python).

 Finally, double check the direction of the TWAVE to make sure it is going in the correct direction.
 This can be accomplished by setting the RF to 0 and m/z of the simulated ion to something ridiculous (1E9).
 This latter aspect is done to have the ion bascially be static during the simulation. Use the PE view
 to see the direction of the TWAVE. 

 Loads SLIM geometry; 
    Creates .fly2
    refine and load .pa0. 

After the refine step, the command box will ask to save the workbench with the same name as lua wb program.
--]]

local convergence = 0.005  -- for a faster refine 1E-5 should be good enough.

-- Utility functions.
local function write_file(filename, data)
  local fh = assert(io.open(filename, 'wb'))
  fh:write(data)
  fh:close()
end


simion.pas:close()  				-- to remove all PA's from RAM.

-- The parameter file below is an example generated by the associated python code
-- Example Parameter File:
-- wElectrode = 0.4064 --Width of the DC electrode (mm)
-- wSF = 3 --Scale factor for the width if desired
-- lElectrode = 3.6576 --Length of the DC electrode (mm)
-- sp = 0.127 --Spacing between electrodes (mm)
-- rfSF = 3 --Scale factor for the width of the RF, if desired
-- wRF = 48 --Width of the RF (mm)
-- gSF = 3 --Guard Scale Factor
-- wGuard = 48 --Width of the Guard (mm)
-- numDC = 8 --Number of DC electrodes per TW Segment
-- numRowsDC = 3 --Number of rows of TWAVE segments
-- numRF = 2 --Number of RF Segments
-- numGuards = 2 --Number of Guard Segments
-- totalLen = 10.769599999999999 --Total Length of the monomer (mm)
-- totalWidth = 6.858 --Total Width of the monomer (mm)
-- d = 1.5875 -- half distance between the layers/boards (mm)

dofile("Extrude_SLIM_Parameters.lua") -- Load the parameter file generated by python
-- extract some params
local lt = totalLen
local lty = totalWidth
local e_dict = elecDict
local des_name = design_title
local splat_rec = splat_line 
local gem = [[
-- Geometry file for Extrude_SLIM

local scale = 0.05 -- mm/gu  ---- define the scale

local lt = totalLen  --total length (mm)

local lty = totalWidth --((wg+sp+(nrf-1)*(weDC+sp+weRF+sp)+weRF+sp+wg))  --Total width of the SLIM

local gu_mm = 1/scale  -- grid units per mm (number of grid units per mm)

local n = 0 
local n1 = 0
local m = 0

------------------------------------------------------------------------------------------------------------------
---- Geometry ------------------------- Only one layer is created and mirrored. 
------------------------------------------------------------------------------------------------------------------

pa_define{wx=math.floor(lt)+1,wy=math.floor(lty)+1,wz=math.floor(d)+1,dx=scale,mirror='z',surface='fractional'}

locate(0,0,0,1,0,0,0)
{
--Loads all of the electrodes as defined by using Pillow and the Python Script
include("user.gem") -- this is the way -- Produced from the jupyter notebook 
}

]]

write_file(string.format('%s.gem', des_name), gem)

-- there was a .fly2 generation here, I write them with python now - CG

-- partition this long string out

local lua_1 = string.format([[

-- Lua code for Extrude_SLIM.iob
-- Adapted from neurons of Aneesh Prabhakaran -- 22 July 2021
-- BHC July 2022, CG 2023

simion.workbench_program()

-- import standard SDS collision model from this directory.
simion.import("required/collision_sds.lua")
local CON = simion.import('required/contourlib81.lua')
dofile("Extrude_SLIM_Parameters.lua") 

-- user adjustable parametsers
adjustable _frequency_hz       = 0.8E6  
adjustable _RF_amplitude     = 100

adjustable _TW_frequency       = 50    -- KHz --This value is for each step and not the period across all 8 electrodes
adjustable _TW_amplitude       = 8

adjustable phase_angle_deg     = 0.0   -- entry phase angle of ion (deg)

adjustable _GuardV         = 10

adjustable _printsave      = 0

adjustable _userPressure       = 2.5 --Torr

local pe_update_each_usec      = 0.01

local elect_length             = lElectrode  -- length of the electrodes in the gem file
local elect_spacing            = sp

-- numDC    -- number of TWAVE electrodes per segment
local last_pe_update = 0      -- last potential energy surface update time (usec)

local FL  = simion.import 'required/fieldlib.lua'


--------------------------------------------------------
 
function SDS.init()
  function SDS.velocity(x,y,z)
    --vy,vx,vz = vfield (x,y, z)
    vx,vy,vz = 0,0,0  -- just for an example.
    return vx,vy,vz
  end 

  function SDS.pressure(x,y,z) 
    pressure = _userPressure --2.5 --Pfield(x,y, z)
    
    if pressure then
      --print(x, pressure*0.0075)
      return pressure *1 --0.0075
    end
  end 

  -- CON.plot { func=SDS.velocity, z =0, npointsy=20,npointsx=5, vmax='percentile(99)',color=2, mark=true, vscale=1}

end 


 function segment.initialize()
  SDS.segment.initialize()
  --adjustable SDS_pressure_torr = _SDS_pressure_torr
 ion_color = 0
  --

 end
 function segment.initialize_run()
 SDS.segment.initialize_run()

sim_rerun_flym = 0
sim_trajectory_image_control = 1 -- --(0 view+retain, 1 view only, 2 retain only, 3 no view or retain)
sim_trajectory_quality = 0 -- (push T.Qual to zero)
count = 0
masses = {}
tofs = {}
seen = {}

end


function segment.fast_adjust()

-------

  -- Initialize constants once.
    if not theta then
        theta = phase_angle_deg * (3.141592 / 180)      
        -- omega1 = _frequency_hz * 6.28318E-6 --2 pi and time for microseconds
        -- omega2 = _frequency_hz * 6.28318E-6*(-1/3) --2 pi and time for microseconds
        -- omega3 = _frequency_hz * 6.28318E-6*(1/3) --2 pi and time for microseconds
    end

  ---====TRAVELLING WAVE ======------------------
  local wave_speed = (_TW_frequency/1000) * (elect_length + elect_spacing)      -- mm/us
     
  if(_TW_frequency>0) then
   
        local stepping_time = 1/wave_speed         --us/(two electrodes)
        local time_period = numDC*stepping_time
  
    nstep = math.floor(ion_time_of_flight/stepping_time)
    nstep_final = nstep - numDC*math.floor(nstep/numDC) 
  
    n1 = nstep_final + 1   if (n1>8) then n1 = n1-8   end
    n2 = nstep_final + 2   if (n2>8) then n2 = n2-8   end
    n3 = nstep_final + 3   if (n3>8) then n3 = n3-8   end
    n4 = nstep_final + 4   if (n4>8) then n4 = n4-8   end
    n5 = nstep_final + 5   if (n5>8) then n5 = n5-8   end
    n6 = nstep_final + 6   if (n6>8) then n6 = n6-8   end
    n7 = nstep_final + 7   if (n7>8) then n7 = n7-8   end
    n8 = nstep_final + 8   if (n8>8) then n8 = n8-8   end
    -- print("Electrodes: ", n1, n2, n3, n4, n5, n6, n7, n8)
    
    -- square wave (50 percent DC) 
    adj_elect[n1] = _TW_amplitude
    adj_elect[n2] = _TW_amplitude
    adj_elect[n3] = _TW_amplitude
    adj_elect[n4] = _TW_amplitude
     
    adj_elect[n5] = -1*_TW_amplitude --0
    adj_elect[n6] = -1*_TW_amplitude --0
    adj_elect[n7] = -1*_TW_amplitude --0
    adj_elect[n8] = -1*_TW_amplitude --0
  end
   
  ----------------------------- RF Voltage-------------------------------
  local rfvolts = sin(2 * 3.14159 * _frequency_hz * ion_time_of_flight*1E-6) * _RF_amplitude

  -- inject electrode keys
  adj_elect[%s] = rfvolts 
  adj_elect[%s] = rfvolts*-1

  adj_elect[%s] = _TW_amplitude/2 + _GuardV ------ Guard voltage ------
  --  add extra electrodes below this line, update string format
-------


end 

 function segment.tstep_adjust()
  SDS.segment.tstep_adjust()
  frequency_Mhz = _frequency_hz * 10^-6
  step_size = 0.10*(1/ frequency_Mhz)
  step_size = 0.01*(1/ frequency_Mhz)
   
  ion_time_step = math.min(ion_time_step, step_size)  
   --mark()
end

]], e_dict["RF1"], e_dict["RF2"], e_dict["G"])

 -- inject finish line >>
local lua_2 = string.format([[

function segment.other_actions()
  
  SDS.segment.other_actions()

  -- Adjust these boolean operators to set the splat conditions. 
  -- I don't bother with a border all the way around the edge... 
    -- if the ions escape they will splat in the z direction

  -- if ion_px_mm <= s or ion_py_mm <= s or ion_py_mm >= s or ion_px_mm >= s then

  if %s <= ion_px_mm and ion_px_mm <= %s and %s <= ion_py_mm and ion_py_mm<= %s then -- splat rectangle method
    ion_splat = 1

  end
  if abs(ion_time_of_flight - last_pe_update) >= pe_update_each_usec then
    last_pe_update = ion_time_of_flight
    sim_update_pe_surface = 1    -- Request a PE surface display update.
  end
  
  
end
 
]], splat_rec[1], splat_rec[3], splat_rec[2], splat_rec[4])

local lua = lua_1 .. lua_2
write_file(string.format('%s.lua', des_name), lua)  

simion.command(string.format('gem2pa %s.gem %s.pa#', des_name, des_name))
local pa = simion.pas:open(string.format('%s.pa#', des_name))

-- create and refine or not depending on the convergence value; .pa0, .pa1, .pa2, ...
pa:refine{convergence=convergence}
pa:save()


pa:load(string.format('%s.pa0', des_name))

print(string.format('\n\n\n Refining is complete... Now,save the workbench as %s.iob \n\n\n', des_name))
--  does what the ion bench is saved as need to change to change fileNames?

